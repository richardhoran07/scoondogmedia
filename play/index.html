<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Physics Music Sandbox | SCOONDOG156</title>
  <style>
    body {
      margin: 0;
      background: black;
      font-family: 'UnifrakturCook', cursive;
      overflow: hidden;
      height: 100vh;
    }
    #back-btn, #chaos-btn {
      position: absolute;
      top: 10px;
      padding: .4rem .7rem;
      border: 2px double #000;
      background: rgba(255,255,255,0.85);
      text-decoration: none;
      color: #000;
      font-size: 1rem;
      z-index: 10;
    }
    #back-btn { left: 10px; }
    #chaos-btn { right: 10px; cursor: pointer; }
    #start-btn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 1rem 2rem;
      border: 3px solid #000;
      background: #fff;
      color: #000;
      font-size: 1.5rem;
      cursor: pointer;
      z-index: 20;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0; left: 0;
      z-index: 1;
    }
  </style>
</head>
<body>
  <a id="back-btn" href="../">â¬… Back</a>
  <button id="chaos-btn">Chaos!</button>
  <button id="start-btn">Start</button>
  <canvas id="scene"></canvas>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.161.0/build/three.min.js"></script>
  <!-- Tone.js -->
  <script src="https://cdn.jsdelivr.net/npm/tone@14.8.49/build/Tone.js"></script>

  <script>
    const startBtn = document.getElementById("start-btn");
    const chaosBtn = document.getElementById("chaos-btn");
    const canvas = document.getElementById("scene");

    let scene, camera, renderer;
    let balls = [], guys = [], orb, ground;
    let drum, flute, pad, pop;
    let grabbed = null;

    // --- START ---
    startBtn.addEventListener("click", async () => {
      await Tone.start();
      startBtn.style.display = "none";
      initInstruments();
      initVisuals();
      spawnWorld();
    });

    // --- Instruments ---
    function initInstruments() {
      const reverb = new Tone.Reverb({ decay: 4, wet: 0.3 }).toDestination();
      const limiter= new Tone.Limiter(-6).toDestination();

      drum = new Tone.MembraneSynth().connect(reverb).connect(limiter);
      flute = new Tone.Synth({ oscillator: { type: "sine" } }).connect(reverb).connect(limiter);
      pad   = new Tone.PolySynth(Tone.Synth).connect(reverb).connect(limiter);
      pop   = new Tone.Synth({
        oscillator: { type: "square" },
        envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
      }).connect(limiter);
    }

    // --- Visuals ---
    function initVisuals() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, 14);

      renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 1);

      // Dreamy gradient sky
      const skyGeo = new THREE.SphereGeometry(50, 32, 32);
      const skyMat = new THREE.ShaderMaterial({
        side: THREE.BackSide,
        uniforms: { time: { value: 0 } },
        vertexShader: `varying vec3 vUv;
          void main(){ vUv = position; gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0);} `,
        fragmentShader: `uniform float time; varying vec3 vUv;
          void main(){
            float pulse = sin(time*0.05 + vUv.y*0.1)*0.5+0.5;
            gl_FragColor = vec4(0.3+0.3*pulse,0.6+0.4*sin(vUv.y*0.2+time*0.05),1.0,1.0);
          }`
      });
      const sky = new THREE.Mesh(skyGeo, skyMat);
      scene.add(sky);

      // Lights
      scene.add(new THREE.AmbientLight(0xffffff, 0.7));
      const point = new THREE.PointLight(0xffffff, 1.5);
      point.position.set(5,8,5);
      scene.add(point);

      // Ground
      ground = new THREE.Mesh(
        new THREE.PlaneGeometry(30,30),
        new THREE.MeshPhongMaterial({ color: 0x88cc88, side: THREE.DoubleSide })
      );
      ground.rotation.x = -Math.PI/2;
      ground.position.y = -2;
      scene.add(ground);

      // Orb
      orb = new THREE.Mesh(
        new THREE.SphereGeometry(2, 48, 48),
        new THREE.MeshPhongMaterial({ color: 0xff99cc, shininess: 80 })
      );
      orb.position.y = 1;
      scene.add(orb);

      // Resize
      window.addEventListener("resize",()=>{
        camera.aspect=window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth,window.innerHeight);
      });

      // Animate
      function animate(t){
        requestAnimationFrame(animate);
        sky.material.uniforms.time.value = t*0.001;
        stepWorld();
        renderer.render(scene,camera);
      }
      animate(0);
    }

    // --- World spawn/reset ---
    function spawnWorld(){
      // clear old
      balls.forEach(b=>scene.remove(b));
      guys.forEach(g=>scene.remove(g));
      balls=[]; guys=[];

      // Balls
      for (let i=0;i<8;i++){
        const mesh=new THREE.Mesh(
          new THREE.SphereGeometry(0.6,32,32),
          new THREE.MeshPhongMaterial({ color:new THREE.Color().setHSL(Math.random(),0.7,0.6) })
        );
        mesh.position.set((Math.random()-0.5)*10, Math.random()*5+1, (Math.random()-0.5)*10);
        mesh.userData.vel=new THREE.Vector3((Math.random()-0.5)*0.1,0,(Math.random()-0.5)*0.1);
        mesh.userData.yVel=0;
        scene.add(mesh);
        balls.push(mesh);
      }

      // Guys
      for (let i=0;i<6;i++){
        const mesh=new THREE.Mesh(
          new THREE.BoxGeometry(0.5,1,0.5),
          new THREE.MeshPhongMaterial({ color:new THREE.Color().setHSL(Math.random(),0.8,0.5) })
        );
        mesh.position.set((Math.random()-0.5)*10, -1.5, (Math.random()-0.5)*10);
        mesh.userData.vel=new THREE.Vector3((Math.random()-0.5)*0.05,0,(Math.random()-0.5)*0.05);
        scene.add(mesh);
        guys.push(mesh);
      }
    }
    chaosBtn.addEventListener("click",spawnWorld);

    // --- Physics step ---
    function stepWorld(){
      const groundY=-2;
      // Balls
      balls.forEach(ball=>{
        ball.userData.yVel-=0.003;
        ball.position.y+=ball.userData.yVel;
        if(ball.position.y-0.6<=groundY){
          ball.position.y=groundY+0.6;
          ball.userData.yVel*=-0.6;
          drum.triggerAttackRelease("C2","8n");
        }
        ball.position.add(ball.userData.vel);
        if(ball.position.distanceTo(orb.position)<2.6){
          ball.userData.vel.x*=-1; ball.userData.vel.z*=-1;
          flute.triggerAttackRelease("C5","8n");
        }
      });
      // Ball-ball collisions
      for(let i=0;i<balls.length;i++){
        for(let j=i+1;j<balls.length;j++){
          if(balls[i].position.distanceTo(balls[j].position)<1.2){
            balls[i].userData.vel.x*=-1; balls[j].userData.vel.x*=-1;
            pad.triggerAttackRelease(["E4","G4","B4"],"2n");
          }
        }
      }
      // Guys
      guys.forEach(g=>{
        g.position.add(g.userData.vel);
        if(Math.random()<0.01) g.userData.vel.x*=-1;
        if(Math.random()<0.01) g.userData.vel.z*=-1;
        balls.forEach(b=>{
          if(b.position.distanceTo(g.position)<1){
            g.userData.vel.x+=(Math.random()-0.5)*0.2;
            pop.triggerAttackRelease("C6","16n");
          }
        });
      });
      // Grabbed follows pointer
      if(grabbed){
        grabbed.position.lerp(grabbed.targetPos,0.3);
      }
    }

    // --- Mouse grabbing ---
    const raycaster=new THREE.Raycaster();
    const mouse=new THREE.Vector2();
    let dragging=false;
    canvas.addEventListener("mousedown",e=>{
      dragging=true;
      setMouse(e);
      raycaster.setFromCamera(mouse,camera);
      const intersects=raycaster.intersectObjects([...balls,...guys]);
      if(intersects.length>0){
        grabbed=intersects[0].object;
        grabbed.targetPos=grabbed.position.clone();
      }
    });
    canvas.addEventListener("mousemove",e=>{
      if(grabbed){
        setMouse(e);
        raycaster.setFromCamera(mouse,camera);
        const plane=new THREE.Plane(new THREE.Vector3(0,1,0),2);
        const pos=new THREE.Vector3();
        raycaster.ray.intersectPlane(plane,pos);
        grabbed.targetPos=pos;
      }
    });
    canvas.addEventListener("mouseup",()=>{ dragging=false; grabbed=null; });

    function setMouse(e){
      mouse.x=(e.clientX/window.innerWidth)*2-1;
      mouse.y=-(e.clientY/window.innerHeight)*2+1;
    }
  </script>
</body>
</html>
